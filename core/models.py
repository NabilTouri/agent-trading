from pydantic import BaseModel, Field
from typing import Literal, Optional, Dict, List
from datetime import datetime
from enum import Enum
import uuid


# ═══════════════════════════════════════════════════════════════════════════════
# Legacy Models (used by execution layer, API, Redis storage)
# ═══════════════════════════════════════════════════════════════════════════════

class ActionType(str, Enum):
    """Trading action types."""
    BUY = "BUY"
    SELL = "SELL"
    HOLD = "HOLD"


class Signal(BaseModel):
    """Signal generated by the crew analysis cycle."""
    signal_id: str = Field(default_factory=lambda: f"sig_{int(datetime.now().timestamp())}")
    timestamp: datetime = Field(default_factory=datetime.now)
    pair: str
    action: ActionType
    confidence: float = Field(ge=0, le=100)
    reasoning: str
    agent_votes: Dict[str, str]  # {agent_name: action}
    market_data: Dict

    class Config:
        use_enum_values = True


class Position(BaseModel):
    """Open position."""
    position_id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    pair: str
    side: Literal["LONG", "SHORT"]
    entry_price: float
    size: float  # in USDT
    quantity: float  # in BTC/ETH
    leverage: int = 1
    stop_loss: float
    take_profit: Optional[float] = None
    opened_at: datetime = Field(default_factory=datetime.now)
    signal_id: str


class Trade(BaseModel):
    """Completed trade."""
    trade_id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    position_id: str
    pair: str
    side: Literal["LONG", "SHORT"]
    entry_price: float
    exit_price: float
    size: float
    quantity: float
    pnl: float  # Profit/Loss in USDT
    pnl_percent: float
    fees: float
    opened_at: datetime
    closed_at: datetime = Field(default_factory=datetime.now)
    duration_minutes: int
    exit_reason: Literal["TP", "SL", "SIGNAL", "MANUAL"]


class OrderRequest(BaseModel):
    """Order request to execute."""
    pair: str
    side: Literal["BUY", "SELL"]
    order_type: Literal["MARKET", "LIMIT"]
    quantity: float
    price: Optional[float] = None
    stop_loss: Optional[float] = None
    take_profit: Optional[float] = None


# ═══════════════════════════════════════════════════════════════════════════════
# CrewAI Output Models (structured output from the 3-agent crew)
# ═══════════════════════════════════════════════════════════════════════════════

class EntryOrder(BaseModel):
    """Single entry order in a scaled entry plan."""
    price: float
    size: float  # in USDT


class EntryPlan(BaseModel):
    """Entry execution plan."""
    method: Literal["MARKET", "LIMIT"] = "LIMIT"
    price: float
    orders: List[EntryOrder] = Field(default_factory=list)


class StopLossLevel(BaseModel):
    """Stop loss configuration."""
    price: float
    pct: float  # distance from entry as percentage
    type: Literal["STOP_LIMIT", "STOP_MARKET"] = "STOP_LIMIT"


class TakeProfitLevel(BaseModel):
    """Single take profit level."""
    level: int
    price: float
    size_pct: float  # percentage of position to close at this level


class TradeDecision(BaseModel):
    """
    Final structured output from the CrewAI trading crew.
    
    This is the JSON schema that the Trading Operations Agent must produce.
    It contains the complete trade plan: direction, sizing, entry/exit levels,
    and risk parameters.
    """
    decision: Literal["APPROVED", "REJECTED"]
    pair: str
    direction: Literal["LONG", "SHORT"]
    confidence: int = Field(ge=0, le=100)
    position_size_usd: float = Field(ge=0)
    position_size_pct: float = Field(ge=0, le=100)
    entry: EntryPlan
    stop_loss: StopLossLevel
    take_profit: List[TakeProfitLevel] = Field(default_factory=list)
    risk_reward_ratio: float = Field(ge=0)
    reasoning: str

    # Metadata from agents
    market_analysis_summary: str = ""
    sentiment_summary: str = ""


class SafeguardResult(BaseModel):
    """Result of a single safeguard check."""
    check_name: str
    passed: bool
    reason: str


class SafeguardReport(BaseModel):
    """Aggregate result of all safeguard checks."""
    approved: bool
    checks: List[SafeguardResult]
    blocked_reason: Optional[str] = None
